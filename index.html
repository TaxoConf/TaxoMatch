<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TaxoConf Task Workspace</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-1: #f8f2e7;
      --bg-2: #ecf5f3;
      --ink: #1c2a38;
      --ink-soft: #4e6073;
      --panel: rgba(255, 255, 255, 0.9);
      --line: #d9e2e0;
      --accent: #138f8b;
      --accent-strong: #0f7673;
      --accent-warm: #e06a2d;
      --accent-muted: #8ea65f;
      --danger: #b53d33;
      --shadow: 0 14px 34px rgba(24, 48, 67, 0.12);
      --radius: 16px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Space Grotesk", "Trebuchet MS", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 8% 0%, rgba(224, 106, 45, 0.18), transparent 42%),
        radial-gradient(circle at 88% 14%, rgba(19, 143, 139, 0.2), transparent 40%),
        linear-gradient(165deg, var(--bg-1), var(--bg-2) 54%, #fbefe0 100%);
    }

    .app {
      width: min(1520px, 96vw);
      margin: 16px auto 24px;
      display: grid;
      grid-template-columns: 280px minmax(0, 1fr);
      gap: 14px;
    }

    .panel {
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid rgba(255, 255, 255, 0.78);
      box-shadow: var(--shadow);
    }

    .sidebar {
      padding: 14px;
      position: sticky;
      top: 12px;
      height: fit-content;
      max-height: calc(100vh - 24px);
      overflow: auto;
    }

    .brand {
      padding: 8px 8px 12px;
      border-bottom: 1px solid #e7f0ee;
      margin-bottom: 12px;
    }

    .brand h1 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: -0.02em;
    }

    .brand p {
      margin: 4px 0 0;
      font-size: 0.78rem;
      color: var(--ink-soft);
      line-height: 1.35;
    }

    .nav-list {
      display: grid;
      gap: 8px;
    }

    .nav-btn {
      text-align: left;
      border: 1px solid #d7e5e2;
      border-radius: 12px;
      background: #f3faf8;
      color: #2e4f62;
      padding: 10px 12px;
      font-family: inherit;
      font-size: 0.86rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .nav-btn.is-active {
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      color: #fff;
      border-color: transparent;
      box-shadow: 0 7px 16px rgba(15, 118, 115, 0.24);
    }

    .sidebar-meta {
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px dashed #d3e3df;
      font-size: 0.74rem;
      color: var(--ink-soft);
    }

    .content {
      display: grid;
      gap: 14px;
    }

    .task-view {
      display: none;
      gap: 14px;
    }

    .task-view.is-active {
      display: grid;
      animation: reveal 0.2s ease;
    }

    @keyframes reveal {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .setup-panel,
    .result-panel {
      padding: 14px;
    }

    .setup-panel h2,
    .result-panel h2 {
      margin: 0 0 10px;
      font-size: 1.02rem;
      letter-spacing: -0.01em;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items: start;
    }

    .grid-3 {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    .control-card {
      border: 1px solid #e5efec;
      background: #fff;
      border-radius: 12px;
      padding: 10px;
    }

    .control-group {
      display: grid;
      gap: 6px;
      margin-bottom: 10px;
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 0.8rem;
      color: var(--ink-soft);
      font-weight: 600;
    }

    .control-value {
      font-family: "IBM Plex Mono", "SFMono-Regular", Consolas, monospace;
      color: #245c61;
      font-size: 0.75rem;
    }

    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      color: var(--ink);
      font-family: inherit;
      font-size: 0.86rem;
      padding: 8px 9px;
    }

    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }

    .toggle-row {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 0.82rem;
      color: #3f5a6c;
      margin: 5px 0;
    }

    .btn-row {
      display: grid;
      gap: 8px;
    }

    button {
      border: 0;
      border-radius: 10px;
      padding: 10px 12px;
      font-family: inherit;
      font-size: 0.84rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.14s ease;
    }

    button:active {
      transform: translateY(1px);
    }

    .btn-primary {
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      color: #fff;
      box-shadow: 0 7px 18px rgba(15, 118, 115, 0.24);
    }

    .btn-secondary {
      background: linear-gradient(120deg, #f8eee7, #f5dfd0);
      color: #8a4824;
      border: 1px solid rgba(224, 106, 45, 0.21);
    }

    .btn-muted {
      background: linear-gradient(120deg, #edf6f3, #e4efec);
      color: #335566;
      border: 1px solid #d7e6e2;
    }

    .tiny {
      font-size: 0.74rem;
      color: var(--ink-soft);
      line-height: 1.35;
    }

    .summary {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
      margin-bottom: 10px;
    }

    .metric {
      border: 1px solid #e7efed;
      background: #fff;
      border-radius: 10px;
      padding: 9px;
    }

    .metric .label {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #5d7081;
      margin-bottom: 3px;
    }

    .metric .value {
      font-size: 1.05rem;
      font-weight: 700;
    }

    .table-wrap {
      overflow: auto;
      border: 1px solid #e7eeec;
      border-radius: 10px;
      background: #fff;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 760px;
      font-size: 0.79rem;
    }

    th,
    td {
      border-bottom: 1px solid #eef2f1;
      padding: 8px 9px;
      text-align: left;
      vertical-align: top;
    }

    th {
      background: #f6fbfa;
      color: #4c6375;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    tbody tr.clickable { cursor: pointer; }
    tbody tr.clickable:hover { background: #f6fbfa; }
    tbody tr.selected { background: #eaf8f5; }

    .badge {
      display: inline-block;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 700;
      border: 1px solid transparent;
      white-space: nowrap;
    }

    .badge-ok {
      color: #0f6b68;
      background: rgba(19, 143, 139, 0.13);
      border-color: rgba(19, 143, 139, 0.26);
    }

    .badge-warn {
      color: #8f4f27;
      background: rgba(224, 106, 45, 0.14);
      border-color: rgba(224, 106, 45, 0.28);
    }

    .badge-danger {
      color: #91352f;
      background: rgba(181, 61, 51, 0.12);
      border-color: rgba(181, 61, 51, 0.23);
    }

    .badge-muted {
      color: #395c6f;
      background: #eef5f2;
      border-color: #d8e7e3;
    }

    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .small-tab {
      border: 1px solid #d8e7e3;
      border-radius: 999px;
      background: #eef7f5;
      color: #33596a;
      padding: 6px 10px;
      font-size: 0.76rem;
      font-weight: 700;
      cursor: pointer;
    }

    .small-tab.is-active {
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      color: #fff;
      border-color: transparent;
    }

    .result-split {
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 12px;
      align-items: start;
    }

    .detail-card,
    .gap-card,
    .list-card {
      border: 1px solid #e5efec;
      background: #fff;
      border-radius: 12px;
      padding: 10px;
    }

    .detail-card h3,
    .gap-card h3,
    .list-card h3 {
      margin: 0 0 8px;
      font-size: 0.9rem;
      color: #304b5c;
    }

    .bars {
      display: grid;
      gap: 7px;
    }

    .bar-row {
      display: grid;
      grid-template-columns: minmax(120px, 1fr) minmax(130px, 2fr) 56px;
      gap: 7px;
      align-items: center;
      font-size: 0.76rem;
    }

    .bar-track {
      height: 9px;
      border-radius: 999px;
      background: #edf4f2;
      border: 1px solid #dce9e5;
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #57b9b5);
    }

    .bar-fill.warm {
      background: linear-gradient(90deg, var(--accent-warm), #eba15f);
    }

    .bar-fill.muted {
      background: linear-gradient(90deg, #93b76a, #aacb81);
    }

    .mono {
      font-family: "IBM Plex Mono", "SFMono-Regular", Consolas, monospace;
      font-size: 0.74rem;
    }

    .schedule-table {
      overflow: auto;
      border: 1px solid #e7efed;
      border-radius: 10px;
      background: #fff;
      margin-bottom: 10px;
    }

    .schedule-table table {
      min-width: 680px;
    }

    .schedule-cell {
      min-height: 74px;
      display: grid;
      gap: 5px;
    }

    .pill {
      display: inline-block;
      border: 1px solid #d8e7e3;
      border-radius: 999px;
      background: #eef7f5;
      padding: 3px 7px;
      font-size: 0.7rem;
      margin-right: 5px;
      margin-top: 4px;
    }

    .poster-grid {
      border: 1px solid #e7efed;
      border-radius: 10px;
      overflow: auto;
      background: #fff;
      margin-bottom: 10px;
    }

    .poster-grid table {
      min-width: 620px;
    }

    .poster-cell {
      min-height: 70px;
      font-size: 0.76rem;
    }

    .editor-table {
      overflow: auto;
      border: 1px solid #e7efed;
      border-radius: 10px;
      background: #fff;
      margin-top: 10px;
    }

    .editor-table table {
      min-width: 760px;
    }

    @media (max-width: 1160px) {
      .app {
        grid-template-columns: 1fr;
      }

      .sidebar {
        position: static;
        max-height: none;
      }
    }

    @media (max-width: 920px) {
      .grid-2,
      .grid-3,
      .result-split {
        grid-template-columns: 1fr;
      }

      .summary {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 620px) {
      .summary {
        grid-template-columns: 1fr;
      }

      .bar-row {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="panel sidebar">
      <div class="brand">
        <h1>TaxoConf Workspace</h1>
        <p>Switch tasks in this navigation drawer. Each task has its own setup panel and result panel.</p>
      </div>
      <div class="nav-list" role="navigation" aria-label="Task Navigation">
        <button class="nav-btn is-active" data-task="assignment" type="button">Paper Assignment</button>
        <button class="nav-btn" data-task="discovery" type="button">PC Member Discovery</button>
        <button class="nav-btn" data-task="oral" type="button">Oral Session Organization</button>
        <button class="nav-btn" data-task="poster" type="button">Poster Session Organization</button>
      </div>
      <div class="sidebar-meta">
        <div>Core metric: weighted Tree-Wasserstein</div>
        <div>Synthesized defaults loaded on startup.</div>
      </div>
    </aside>

    <main class="content">
      <section class="task-view is-active" id="task-assignment">
        <section class="panel setup-panel">
          <h2>Setup Panel: Paper Assignment</h2>
          <div class="grid-3">
            <div class="control-card">
              <h3 style="margin:0 0 8px;font-size:0.9rem">Upload Inputs</h3>
              <div class="btn-row">
                <button id="uploadSubmissionBtn" class="btn-secondary" type="button">Upload Submissions JSON</button>
                <input id="submissionFileInput" type="file" accept=".json" style="display:none">
                <button id="uploadPcBtn" class="btn-secondary" type="button">Upload PC Members JSON</button>
                <input id="pcFileInput" type="file" accept=".json" style="display:none">
                <button id="uploadCoiBtn" class="btn-secondary" type="button">Upload COI Matrix JSON</button>
                <input id="coiFileInput" type="file" accept=".json" style="display:none">
              </div>
              <div id="assignmentUploadStatus" class="tiny" style="margin-top:8px"></div>
            </div>

            <div class="control-card">
              <h3 style="margin:0 0 8px;font-size:0.9rem">Parameters</h3>
              <div class="control-group">
                <span class="control-label">Reviewer Workload (papers/member)</span>
                <input id="workloadInput" type="number" min="1" step="1" value="4">
              </div>
              <div class="control-group">
                <span class="control-label">Coverage (reviews/paper)</span>
                <input id="coverageInput" type="number" min="1" step="1" value="3">
              </div>
              <div class="control-group">
                <span class="control-label">Topic Top-k for Matching <span class="control-value" id="assignTopKValue">4</span></span>
                <input id="assignTopKInput" type="range" min="2" max="8" step="1" value="4">
              </div>
              <label class="toggle-row">
                <input id="strictCoiInput" type="checkbox" checked>
                Enforce COI constraints
              </label>
              <div class="btn-row" style="margin-top:8px">
                <button id="runAssignmentBtn" class="btn-primary" type="button">Run Assignment</button>
              </div>
            </div>

            <div class="control-card">
              <h3 style="margin:0 0 8px;font-size:0.9rem">Expected JSON Schema</h3>
              <div class="tiny">
                Submission:<br>
                <code>{ submission_id, title, abstract, authors }</code><br><br>
                PC member:<br>
                <code>{ pc_id, role, name, publication_history:[{title, abstract}] }</code><br><br>
                COI matrix (supported):<br>
                <code>[{submission_id, pc_id, conflict:true}]</code> or nested object map.
              </div>
            </div>
          </div>
        </section>

        <section class="panel result-panel">
          <h2>Main Panel: Assignment Result</h2>
          <div id="assignmentSummary" class="summary"></div>

          <div class="tabs">
            <button id="paperViewBtn" class="small-tab is-active" type="button">Paper View</button>
            <button id="pcViewBtn" class="small-tab" type="button">PC Member View</button>
          </div>

          <div class="result-split">
            <div class="list-card">
              <h3 id="assignmentListTitle">Paper View List</h3>
              <div id="assignmentListTable" class="table-wrap"></div>
            </div>
            <div class="detail-card">
              <h3>Detail + Topic Distribution Explanation</h3>
              <div id="assignmentDetailPanel" class="tiny">Run assignment and click a paper or PC member to inspect details.</div>
            </div>
          </div>
        </section>
      </section>

      <section class="task-view" id="task-discovery">
        <section class="panel setup-panel">
          <h2>Setup Panel: PC Member Discovery</h2>
          <div class="grid-3">
            <div class="control-card">
              <div class="control-group">
                <span class="control-label">External Candidate Source</span>
                <select id="discoverySourceSelect">
                  <option value="OpenReview">OpenReview</option>
                  <option value="Semantic Scholar">Semantic Scholar</option>
                </select>
              </div>
              <div class="control-group">
                <span class="control-label">Required Role</span>
                <select id="discoveryRoleSelect">
                  <option value="Reviewer">Reviewer</option>
                  <option value="Area Chair">Area Chair</option>
                  <option value="Senior Area Chair">Senior Area Chair</option>
                </select>
              </div>
              <div class="control-group">
                <span class="control-label">Required PC Member Count</span>
                <input id="discoveryCountInput" type="number" min="1" step="1" value="8">
              </div>
              <div class="btn-row">
                <button id="runDiscoveryBtn" class="btn-primary" type="button">Start Search</button>
              </div>
            </div>

            <div class="control-card">
              <h3 style="margin:0 0 8px;font-size:0.9rem">Behavior</h3>
              <div class="tiny">
                1. Compute current expertise-topic gap from uploaded submissions and current PC members.<br>
                2. Search candidates from selected source + role.<br>
                3. Auto-select top recommended candidates.<br>
                4. You can add/remove candidates in the result list; gap panel updates instantly.
              </div>
            </div>

            <div class="control-card">
              <h3 style="margin:0 0 8px;font-size:0.9rem">Inputs Used</h3>
              <div id="discoveryInputStatus" class="tiny"></div>
            </div>
          </div>
        </section>

        <section class="panel result-panel">
          <h2>Main Panel: Discovery Result</h2>
          <div class="result-split">
            <div class="gap-card">
              <h3>Expertise Gap (Before / After Selected Candidates)</h3>
              <div id="discoveryGapPanel" class="tiny">Run search to compute the gap.</div>
            </div>
            <div class="list-card">
              <h3>Candidate List (recommended selected by default)</h3>
              <div id="discoveryCandidateTable" class="table-wrap"></div>
            </div>
          </div>
        </section>
      </section>

      <section class="task-view" id="task-oral">
        <section class="panel setup-panel">
          <h2>Setup Panel: Oral Session Organization</h2>
          <div class="grid-3">
            <div class="control-card">
              <div class="btn-row">
                <button id="uploadOralPapersBtn" class="btn-secondary" type="button">Upload Oral Paper List</button>
                <input id="oralFileInput" type="file" accept=".json" style="display:none">
              </div>
              <div id="oralUploadStatus" class="tiny" style="margin-top:8px"></div>
            </div>

            <div class="control-card">
              <div class="control-group">
                <span class="control-label">Number of Parallel Sessions</span>
                <input id="oralParallelInput" type="number" min="1" step="1" value="2">
              </div>
              <div class="control-group">
                <span class="control-label">Maximum Papers per Session</span>
                <input id="oralMaxInput" type="number" min="1" step="1" value="4">
              </div>
              <div class="control-group">
                <span class="control-label">Total Number of Time Slots</span>
                <input id="oralSlotsInput" type="number" min="1" step="1" value="2">
              </div>
              <div class="btn-row">
                <button id="runOralBtn" class="btn-primary" type="button">Run Oral Organization</button>
              </div>
            </div>

            <div class="control-card">
              <div class="btn-row">
                <button id="exportOralBtn" class="btn-muted" type="button">Export Oral Result JSON</button>
              </div>
              <div class="tiny" style="margin-top:8px">After run, you can manually adjust assignments in the editor below. Export will use your adjusted final state.</div>
            </div>
          </div>
        </section>

        <section class="panel result-panel">
          <h2>Main Panel: Oral Schedule Result</h2>
          <div id="oralSummary" class="summary"></div>
          <div id="oralSchedulePanel" class="schedule-table"></div>
          <div class="editor-table" id="oralEditorPanel"></div>
        </section>
      </section>

      <section class="task-view" id="task-poster">
        <section class="panel setup-panel">
          <h2>Setup Panel: Poster Session Organization</h2>
          <div class="grid-3">
            <div class="control-card">
              <div class="btn-row">
                <button id="uploadPosterPapersBtn" class="btn-secondary" type="button">Upload Poster Paper List</button>
                <input id="posterFileInput" type="file" accept=".json" style="display:none">
              </div>
              <div id="posterUploadStatus" class="tiny" style="margin-top:8px"></div>
            </div>

            <div class="control-card">
              <div class="control-group">
                <span class="control-label">Venue Capacity Rows (N)</span>
                <input id="posterRowsInput" type="number" min="1" step="1" value="3">
              </div>
              <div class="control-group">
                <span class="control-label">Venue Capacity Columns (M)</span>
                <input id="posterColsInput" type="number" min="1" step="1" value="4">
              </div>
              <div class="control-group">
                <span class="control-label">Session Count</span>
                <input id="posterSessionCountInput" type="number" min="1" step="1" value="2">
              </div>
              <div class="btn-row">
                <button id="runPosterBtn" class="btn-primary" type="button">Run Poster Organization</button>
              </div>
            </div>

            <div class="control-card">
              <div class="btn-row">
                <button id="exportPosterBtn" class="btn-muted" type="button">Export Poster Result JSON</button>
              </div>
              <div class="tiny" style="margin-top:8px">Each table cell maps to a poster board. Manual adjustments in editor are reflected in export.</div>
            </div>
          </div>
        </section>

        <section class="panel result-panel">
          <h2>Main Panel: Poster Arrangement Result</h2>
          <div id="posterSummary" class="summary"></div>
          <div id="posterGridPanel"></div>
          <div class="editor-table" id="posterEditorPanel"></div>
        </section>
      </section>
    </main>
  </div>

  <script>
    const taxonomy = [
      { id: "root", parent: null, label: "Information Retrieval", w: 0, leaf: false },
      { id: "retrieval_core", parent: "root", label: "Retrieval Core", w: 0.34, leaf: false },
      { id: "gen_interactive", parent: "root", label: "Generative & Interactive IR", w: 0.31, leaf: false },
      { id: "recsys", parent: "root", label: "Recommendation", w: 0.29, leaf: false },
      { id: "methods", parent: "root", label: "Representation & Graph Methods", w: 0.28, leaf: false },
      { id: "evaluation", parent: "root", label: "Evaluation & Responsible IR", w: 0.30, leaf: false },
      { id: "reliability", parent: "root", label: "Reliability & Security", w: 0.30, leaf: false },
      { id: "neural_rank", parent: "retrieval_core", label: "Neural Ranking & Re-ranking", w: 0.18, leaf: true },
      { id: "index_ann", parent: "retrieval_core", label: "Indexing & ANN Systems", w: 0.17, leaf: true },
      { id: "gen_rag", parent: "gen_interactive", label: "Generative Retrieval & RAG", w: 0.18, leaf: true },
      { id: "convo_ir", parent: "gen_interactive", label: "Conversational & Interactive IR", w: 0.16, leaf: true },
      { id: "seq_rec", parent: "recsys", label: "Sequential Recommendation", w: 0.17, leaf: true },
      { id: "rec_objective", parent: "recsys", label: "Recommendation Objectives", w: 0.16, leaf: true },
      { id: "graph_method", parent: "methods", label: "Graph-based Modeling", w: 0.17, leaf: true },
      { id: "repr_embed", parent: "methods", label: "Embedding & Representation Learning", w: 0.16, leaf: true },
      { id: "user_eval", parent: "evaluation", label: "User, Evaluation & Explainability", w: 0.17, leaf: true },
      { id: "fair_bias", parent: "evaluation", label: "Fairness & Bias Mitigation", w: 0.16, leaf: true },
      { id: "robust_secure", parent: "reliability", label: "Robustness & Security", w: 0.17, leaf: true }
    ];

    const keywordLexicon = {
      neural_rank: [
        ["dense retrieval", 2.2], ["retrieval", 0.6], ["ranking", 1.6], ["re-ranking", 1.7], ["reranking", 1.7],
        ["cross-encoder", 1.9], ["bi-encoder", 1.8], ["learning-to-rank", 1.8], ["ranker", 1.2]
      ],
      index_ann: [
        ["index", 1.6], ["indexing", 1.6], ["ann", 1.8], ["approximate nearest neighbor", 2.0],
        ["nearest neighbor", 1.7], ["multi-vector", 1.7], ["vector search", 1.5], ["latency", 1.3],
        ["throughput", 1.2], ["scalable", 1.2], ["infrastructure", 1.3], ["benchmark", 1.2]
      ],
      gen_rag: [
        ["rag", 2.3], ["retrieval-augmented", 2.2], ["retrieval augmented", 2.2], ["large language model", 1.9],
        ["llm", 1.9], ["generative retrieval", 2.0], ["fact-check", 1.8], ["question-answer", 1.7],
        ["reasoning", 1.5], ["prompt", 1.4], ["alignment", 1.3]
      ],
      convo_ir: [
        ["conversational", 2.0], ["dialogue", 1.8], ["interactive search", 1.8], ["voice search", 1.7],
        ["clarification", 1.3], ["search behavior", 1.4], ["search behaviour", 1.4], ["user simulation", 1.3]
      ],
      seq_rec: [
        ["sequential recommendation", 2.2], ["session-based recommendation", 2.2], ["session recommendation", 2.0],
        ["next-item", 1.8], ["next item", 1.8], ["click sequence", 1.4], ["temporal user", 1.3]
      ],
      rec_objective: [
        ["recommendation objective", 1.8], ["multi-objective", 1.7], ["personalization", 1.4], ["diversified", 1.4],
        ["item-item", 1.4], ["collaborative filtering", 1.8], ["recommender systems", 1.2], ["exposure", 1.2]
      ],
      graph_method: [
        ["graph neural", 2.1], ["gnn", 2.1], ["graph-based", 1.9], ["hypergraph", 2.0],
        ["knowledge graph", 1.9], ["proximity graph", 1.8], ["message passing", 1.4]
      ],
      repr_embed: [
        ["embedding", 1.9], ["representation learning", 1.8], ["neural embedding", 2.0], ["hyperbolic", 1.8],
        ["distance approximation", 1.8], ["latent space", 1.4], ["metric learning", 1.4], ["diffusion", 1.2]
      ],
      user_eval: [
        ["evaluation", 1.7], ["benchmark", 1.5], ["calibration", 1.7], ["explainability", 1.8], ["shap", 1.8],
        ["user study", 1.6], ["measurement", 1.3], ["effectiveness", 1.3], ["search behaviours", 1.4]
      ],
      fair_bias: [
        ["fairness", 2.1], ["bias", 2.0], ["equity", 1.8], ["debias", 1.8], ["source bias", 2.0],
        ["polarization", 1.7], ["responsible ai", 1.4]
      ],
      robust_secure: [
        ["robust", 1.9], ["robustness", 1.9], ["adversarial", 1.9], ["drift", 1.6], ["noise", 1.3],
        ["security", 1.7], ["cyber threat", 1.8], ["reliability", 1.6], ["trust", 1.3], ["verification", 1.3]
      ]
    };

    const byId = Object.fromEntries(taxonomy.map((x) => [x.id, x]));
    const children = {};
    taxonomy.forEach((n) => {
      if (!n.parent) return;
      if (!children[n.parent]) children[n.parent] = [];
      children[n.parent].push(n.id);
    });
    const leafIds = taxonomy.filter((x) => x.leaf).map((x) => x.id);

    const descendants = {};
    function collectLeaves(nodeId) {
      if (descendants[nodeId]) return descendants[nodeId];
      const node = byId[nodeId];
      if (node.leaf) {
        descendants[nodeId] = [nodeId];
        return descendants[nodeId];
      }
      descendants[nodeId] = (children[nodeId] || []).flatMap((c) => collectLeaves(c));
      return descendants[nodeId];
    }
    taxonomy.forEach((n) => collectLeaves(n.id));

    function normalizeDist(dist) {
      const out = {};
      let sum = 0;
      leafIds.forEach((id) => {
        const v = Math.max(0, Number(dist[id] || 0));
        out[id] = v;
        sum += v;
      });
      if (sum <= 0) {
        const u = 1 / leafIds.length;
        leafIds.forEach((id) => { out[id] = u; });
        return out;
      }
      leafIds.forEach((id) => { out[id] /= sum; });
      return out;
    }

    function sparsify(dist, topK) {
      const sorted = Object.entries(dist).sort((a, b) => b[1] - a[1]);
      const keep = sorted.slice(0, topK);
      const out = {};
      leafIds.forEach((id) => { out[id] = 0; });
      let sum = 0;
      keep.forEach(([id, v]) => { out[id] = v; sum += v; });
      if (sum <= 0) return out;
      keep.forEach(([id]) => { out[id] /= sum; });
      return out;
    }

    function treeWasserstein(a, b) {
      let d = 0;
      taxonomy.forEach((node) => {
        if (!node.parent) return;
        const delta = descendants[node.id].reduce((acc, leaf) => acc + (a[leaf] || 0) - (b[leaf] || 0), 0);
        d += node.w * Math.abs(delta);
      });
      return d;
    }

    function similarity(a, b, topK = 4) {
      const dd = treeWasserstein(sparsify(a, topK), sparsify(b, topK));
      return Math.exp(-dd);
    }

    function textToDist(text) {
      const lower = String(text || "").toLowerCase();
      const raw = {};
      leafIds.forEach((leaf) => { raw[leaf] = 0.02; });
      Object.entries(keywordLexicon).forEach(([leaf, kws]) => {
        kws.forEach((entry) => {
          const kw = Array.isArray(entry) ? String(entry[0] || "").toLowerCase() : String(entry || "").toLowerCase();
          const w = Array.isArray(entry) ? Number(entry[1] || 1) : 1;
          if (!kw) return;
          let idx = 0;
          while (true) {
            const found = lower.indexOf(kw, idx);
            if (found === -1) break;
            raw[leaf] += w;
            idx = found + kw.length;
          }
        });
      });
      return normalizeDist(raw);
    }

    const hintRules = [
      { leaf: "neural_rank", re: /\b(dense retrieval|ranking|re-ranking|reranking|cross-encoder|bi-encoder|learning-to-rank)\b/g },
      { leaf: "index_ann", re: /\b(index|indexing|ann|approximate nearest neighbor|nearest neighbor|multi-vector|latency|throughput|infrastructure)\b/g },
      { leaf: "gen_rag", re: /\b(rag|retrieval-augmented|large language model|llm|generative|fact-check|reasoning|prompt|alignment)\b/g },
      { leaf: "convo_ir", re: /\b(conversational|dialogue|interactive search|voice search|clarification|search behavio[u]?r|user simulation)\b/g },
      { leaf: "seq_rec", re: /\b(sequential|session|next[- ]item|click sequence|temporal user)\b/g },
      { leaf: "rec_objective", re: /\b(recommendation objective|multi-objective|personalization|diversified|collaborative filtering|item-item|exposure)\b/g },
      { leaf: "graph_method", re: /\b(graph neural|gnn|graph-based|hypergraph|knowledge graph|proximity graph|message passing)\b/g },
      { leaf: "repr_embed", re: /\b(embedding|representation learning|neural embedding|hyperbolic|distance approximation|latent space|metric learning|diffusion)\b/g },
      { leaf: "user_eval", re: /\b(evaluation|benchmark|calibration|explainability|shap|user study|effectiveness|measurement)\b/g },
      { leaf: "fair_bias", re: /\b(fairness|bias|equity|debias|source bias|polarization|responsible ai)\b/g },
      { leaf: "robust_secure", re: /\b(robust|robustness|adversarial|drift|noise|security|cyber threat|reliability|trust|verification)\b/g }
    ];

    function inferTopicHintsFromText(text) {
      const lower = String(text || "").toLowerCase();
      const scores = {};
      leafIds.forEach((id) => { scores[id] = 0; });
      hintRules.forEach((rule) => {
        const matches = lower.match(rule.re);
        if (matches && matches.length) scores[rule.leaf] += matches.length;
      });
      const ranked = Object.entries(scores)
        .filter(([, v]) => v > 0)
        .sort((a, b) => b[1] - a[1])
        .map(([id]) => id);
      if (!ranked.length) return ["neural_rank"];
      return ranked.slice(0, 4);
    }

    function hintsToDist(hints) {
      const raw = {};
      leafIds.forEach((id) => { raw[id] = 0.01; });
      const uniq = [...new Set((Array.isArray(hints) ? hints : []).filter((h) => leafIds.includes(h)))];
      if (!uniq.length) return normalizeDist(raw);
      uniq.forEach((h, idx) => {
        raw[h] += Math.max(0.55, 1.2 - idx * 0.2);
      });
      return normalizeDist(raw);
    }

    function blendDists(baseDist, hintDist, textWeight = 0.72) {
      const raw = {};
      leafIds.forEach((id) => {
        raw[id] = textWeight * (baseDist[id] || 0) + (1 - textWeight) * (hintDist[id] || 0);
      });
      return normalizeDist(raw);
    }

    function avgDist(dists) {
      const raw = {};
      leafIds.forEach((l) => { raw[l] = 0; });
      if (!dists.length) return normalizeDist(raw);
      dists.forEach((d) => {
        leafIds.forEach((l) => { raw[l] += d[l] || 0; });
      });
      leafIds.forEach((l) => { raw[l] /= dists.length; });
      return normalizeDist(raw);
    }

    function formatPct(v) { return `${(v * 100).toFixed(1)}%`; }
    function formatNum(v, d = 3) { return Number(v).toFixed(d); }
    function keyPair(subId, pcId) { return `${subId}::${pcId}`; }
    function normalizeAuthors(rawAuthors) {
      if (Array.isArray(rawAuthors)) {
        return rawAuthors
          .map((a) => {
            if (typeof a === "string") return a.trim();
            if (a && typeof a === "object") return String(a.name || a.full_name || a.author_name || "").trim();
            return "";
          })
          .filter(Boolean);
      }
      if (typeof rawAuthors === "string") {
        return rawAuthors.split(",").map((x) => x.trim()).filter(Boolean);
      }
      if (rawAuthors && typeof rawAuthors === "object") {
        const v = String(rawAuthors.name || rawAuthors.full_name || rawAuthors.author_name || "").trim();
        return v ? [v] : [];
      }
      return [];
    }
    function authorsLabel(authors) {
      const arr = normalizeAuthors(authors);
      return arr.length ? arr.join(", ") : "N/A";
    }

    const topicHintAlias = {
      "retrieval core": "neural_rank",
      neural_rank: "neural_rank",
      dense_rank: "neural_rank",
      dense: "neural_rank",
      retrieval: "neural_rank",
      ranking: "neural_rank",
      reranking: "neural_rank",
      "re-ranking": "neural_rank",
      index_ann: "index_ann",
      infra: "index_ann",
      indexing: "index_ann",
      "indexing & ann systems": "index_ann",
      "retrieval infrastructure": "index_ann",
      ann: "index_ann",
      "vector search": "index_ann",
      "generative ir": "gen_rag",
      "generative retrieval": "gen_rag",
      rag: "gen_rag",
      "nlp for ir": "gen_rag",
      llm: "gen_rag",
      conversational: "convo_ir",
      convo_ux: "convo_ir",
      "interactive search": "convo_ir",
      "conversational & interactive ir": "convo_ir",
      seqrec: "seq_rec",
      seq_rec: "seq_rec",
      "sequential recommendation": "seq_rec",
      sequential: "seq_rec",
      session: "seq_rec",
      recsys: "rec_objective",
      "recommender modeling": "rec_objective",
      recsys_model: "rec_objective",
      "recommendation objectives": "rec_objective",
      collab: "rec_objective",
      "collaborative filtering": "rec_objective",
      collaborative: "rec_objective",
      gnn: "graph_method",
      graph: "graph_method",
      graph_rep: "graph_method",
      "graph-based modeling": "graph_method",
      "graph-based learning": "graph_method",
      "graph representation learning": "graph_method",
      deepwalk: "repr_embed",
      embedding: "repr_embed",
      representation: "repr_embed",
      "embedding & representation learning": "repr_embed",
      user_eval: "user_eval",
      "user, evaluation & explainability": "user_eval",
      evaluation: "user_eval",
      robust: "robust_secure",
      robustness: "robust_secure",
      reliability: "robust_secure",
      fair: "fair_bias",
      fairness: "fair_bias",
      fair_xai: "fair_bias",
      bias: "fair_bias",
      explainability: "user_eval"
    };

    function normalizeTopicHints(rawHints) {
      if (!rawHints) return [];
      const arr = Array.isArray(rawHints) ? rawHints : [rawHints];
      return [...new Set(arr
        .map((x) => String(x || "").trim().toLowerCase())
        .map((x) => topicHintAlias[x] || x)
        .filter((x) => leafIds.includes(x)))];
    }

    function topicHintsLabel(hints) {
      const arr = normalizeTopicHints(hints);
      return arr.length ? arr.map((id) => byId[id].label).join(", ") : "N/A";
    }

    const state = {
      activeTask: "assignment",
      assignment: {
        submissions: [],
        pcMembers: [],
        coi: new Set(),
        workload: 4,
        coverage: 3,
        topK: 4,
        strictCoi: true,
        result: null,
        viewMode: "paper",
        selected: null
      },
      discovery: {
        source: "OpenReview",
        role: "Reviewer",
        requiredCount: 8,
        externalCandidates: [],
        recommendedIds: [],
        selectedIds: new Set(),
        result: null
      },
      oral: {
        papers: [],
        parallelSessions: 2,
        maxPerSession: 4,
        timeSlots: 2,
        result: null
      },
      poster: {
        papers: [],
        rows: 3,
        cols: 4,
        sessionCount: 2,
        result: null
      }
    };

    const API_BASE = window.API_BASE
      || ((window.location.protocol === "file:" || !window.location.hostname)
        ? "http://127.0.0.1:8000/api"
        : `${window.location.origin}/api`);

    async function apiPost(path, payload) {
      const res = await fetch(`${API_BASE}${path}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      let data = null;
      try {
        data = await res.json();
      } catch (_) {
        data = null;
      }
      if (!res.ok) {
        const msg = data && data.error ? data.error : `Request failed (${res.status})`;
        throw new Error(msg);
      }
      return data;
    }

    function submissionDist(sub) {
      const text = `${sub.title || ""} ${sub.abstract || ""}`;
      const base = textToDist(text);
      const hints = Array.isArray(sub.topic_hints) && sub.topic_hints.length
        ? normalizeTopicHints(sub.topic_hints)
        : inferTopicHintsFromText(text);
      const textWeight = hints.length ? 0.3 : 0.7;
      return blendDists(base, hintsToDist(hints), textWeight);
    }

    function pcDist(pc) {
      const pubs = Array.isArray(pc.publication_history) ? pc.publication_history : [];
      const fallbackText = `${pc.name || ""} ${pc.title || ""} ${pc.role || ""}`;
      const sourceText = pubs.length
        ? pubs.map((p) => `${p.title || ""} ${p.abstract || ""}`).join(" ")
        : fallbackText;
      const base = pubs.length
        ? avgDist(pubs.map((p) => textToDist(`${p.title || ""} ${p.abstract || ""}`)))
        : textToDist(sourceText);
      const hints = Array.isArray(pc.topic_hints) && pc.topic_hints.length
        ? pc.topic_hints
        : inferTopicHintsFromText(sourceText);
      return blendDists(base, hintsToDist(hints), 0.74);
    }

    function topTopicEntries(dist, limit = 4) {
      return leafIds
        .map((id) => ({ id, v: dist[id] || 0 }))
        .sort((a, b) => b.v - a.v)
        .slice(0, limit);
    }

    function barsHtml(dist, cls = "") {
      return `
        <div class="bars">
          ${topTopicEntries(dist, 6).map((x) => `
            <div class="bar-row">
              <div>${byId[x.id].label}</div>
              <div class="bar-track"><div class="bar-fill ${cls}" style="width:${(x.v * 100).toFixed(2)}%"></div></div>
              <div class="mono">${formatPct(x.v)}</div>
            </div>
          `).join("")}
        </div>
      `;
    }

    function parseJsonFile(file, onSuccess) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const json = JSON.parse(String(e.target.result || ""));
          onSuccess(json);
        } catch (_) {
          alert("Invalid JSON file.");
        }
      };
      reader.onerror = () => alert("Failed to read file.");
      reader.readAsText(file);
    }

    function normalizeSubmissionList(payload) {
      const rows = Array.isArray(payload)
        ? payload
        : Array.isArray(payload.submissions)
          ? payload.submissions
          : [];
      return rows
        .map((x) => ({
          submission_id: x.submission_id || x.id || x.paper_id,
          title: x.title || "Untitled",
          abstract: x.abstract || "",
          authors: normalizeAuthors(x.authors || x.author || x.author_names || x.authorNames),
          topic_hints: normalizeTopicHints(x.topic_hints || x.topics || x.topic_tags || x.topicTags)
        }))
        .filter((x) => x.submission_id);
    }

    function normalizePcList(payload) {
      const rows = Array.isArray(payload)
        ? payload
        : Array.isArray(payload.pc_members)
          ? payload.pc_members
          : Array.isArray(payload.pcMembers)
            ? payload.pcMembers
            : [];

      return rows
        .map((x) => ({
          pc_id: x.pc_id || x.id,
          role: x.role || "Reviewer",
          name: x.name || x.full_name || x.display_name || x.pc_name || x.pc_id || x.id || "Unknown",
          publication_history: Array.isArray(x.publication_history) ? x.publication_history.map((p) => ({ title: p.title || "", abstract: p.abstract || "" })) : []
        }))
        .filter((x) => x.pc_id);
    }

    function normalizeCoi(payload) {
      const set = new Set();

      function push(subId, pcId, flag = true) {
        if (!subId || !pcId) return;
        if (flag) set.add(keyPair(String(subId), String(pcId)));
      }

      if (Array.isArray(payload)) {
        payload.forEach((row) => {
          if (Array.isArray(row) && row.length >= 2) {
            push(row[0], row[1], true);
          } else if (row && typeof row === "object") {
            push(row.submission_id || row.submissionId || row.paper_id, row.pc_id || row.pcId || row.reviewer_id, row.conflict !== false);
          }
        });
      } else if (payload && typeof payload === "object") {
        if (Array.isArray(payload.conflicts)) {
          return normalizeCoi(payload.conflicts);
        }
        Object.entries(payload).forEach(([subId, value]) => {
          if (Array.isArray(value)) {
            value.forEach((pcId) => push(subId, pcId, true));
          } else if (value && typeof value === "object") {
            Object.entries(value).forEach(([pcId, v]) => push(subId, pcId, Boolean(v)));
          }
        });
      }
      return set;
    }

    async function runAssignment() {
      const workload = Math.max(1, Number(document.getElementById("workloadInput").value) || 1);
      const coverage = Math.max(1, Number(document.getElementById("coverageInput").value) || 1);
      const topK = Math.max(2, Number(document.getElementById("assignTopKInput").value) || 4);
      const strictCoi = document.getElementById("strictCoiInput").checked;

      state.assignment.workload = workload;
      state.assignment.coverage = coverage;
      state.assignment.topK = topK;
      state.assignment.strictCoi = strictCoi;

      if (!state.assignment.submissions.length && !state.assignment.pcMembers.length) {
        alert("Submissions and PC member inputs are empty. Please upload both JSON files first.");
        return;
      }
      if (!state.assignment.submissions.length) {
        alert("Submission input is empty. Please upload submissions JSON first.");
        return;
      }
      if (!state.assignment.pcMembers.length) {
        alert("PC member input is empty. Please upload PC member JSON first.");
        return;
      }

      try {
        const resp = await apiPost("/assignment/run", {
          submissions: state.assignment.submissions,
          pc_members: state.assignment.pcMembers,
          coi_pairs: Array.from(state.assignment.coi),
          workload,
          coverage,
          top_k: topK,
          strict_coi: strictCoi
        });
        state.assignment.result = resp.result || null;
        state.assignment.selected = null;
        renderAssignmentResults();
        refreshDiscoveryStatus();
      } catch (err) {
        alert(`Assignment backend error: ${err.message}`);
      }
    }

    function assignmentSummaryCards() {
      const result = state.assignment.result;
      if (!result) {
        return `
          <div class="metric"><div class="label">Submissions</div><div class="value">${state.assignment.submissions.length}</div></div>
          <div class="metric"><div class="label">PC Members</div><div class="value">${state.assignment.pcMembers.length}</div></div>
          <div class="metric"><div class="label">COI Pairs</div><div class="value">${state.assignment.coi.size}</div></div>
          <div class="metric"><div class="label">Status</div><div class="value">Not Run</div></div>
        `;
      }
      const totalRequested = result.byPaper.length * state.assignment.coverage;
      const totalAssigned = result.byPaper.reduce((acc, x) => acc + x.assigned.length, 0);
      const shortage = totalRequested - totalAssigned;
      return `
        <div class="metric"><div class="label">Submissions</div><div class="value">${result.byPaper.length}</div></div>
        <div class="metric"><div class="label">PC Members</div><div class="value">${result.byPc.length}</div></div>
        <div class="metric"><div class="label">Assigned Pairs</div><div class="value">${totalAssigned}</div></div>
        <div class="metric"><div class="label">Coverage Shortage</div><div class="value">${shortage}</div></div>
      `;
    }

    function renderAssignmentList() {
      const container = document.getElementById("assignmentListTable");
      const title = document.getElementById("assignmentListTitle");
      const result = state.assignment.result;
      if (!result) {
        title.textContent = "Result List";
        container.innerHTML = `<div class="tiny" style="padding:10px">Run assignment to generate result views.</div>`;
        return;
      }

      if (state.assignment.viewMode === "paper") {
        title.textContent = "Paper View List";
        container.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>Submission</th>
                <th>Assigned Members</th>
                <th>Coverage</th>
              </tr>
            </thead>
            <tbody>
              ${result.byPaper.map((row) => {
                const selected = state.assignment.selected && state.assignment.selected.type === "paper" && state.assignment.selected.id === row.submission.submission_id;
                return `
                  <tr class="clickable ${selected ? "selected" : ""}" data-type="paper" data-id="${row.submission.submission_id}">
                    <td><strong>${row.submission.submission_id}</strong><br><span class="tiny">${row.submission.title}</span><br><span class="tiny">Authors: ${authorsLabel(row.submission.authors)}</span></td>
                    <td>${row.assigned.map((a) => `<span class="pill">${a.pc.pc_id} - ${a.pc.name}</span>`).join("") || `<span class="badge badge-warn">None</span>`}</td>
                    <td class="mono">${row.assigned.length}/${row.requestedCoverage}</td>
                  </tr>
                `;
              }).join("")}
            </tbody>
          </table>
        `;
      } else {
        title.textContent = "PC Member View List";
        container.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>PC Member</th>
                <th>Assigned Submissions</th>
                <th>Load</th>
              </tr>
            </thead>
            <tbody>
              ${result.byPc.map((row) => {
                const selected = state.assignment.selected && state.assignment.selected.type === "pc" && state.assignment.selected.id === row.pc.pc_id;
                return `
                  <tr class="clickable ${selected ? "selected" : ""}" data-type="pc" data-id="${row.pc.pc_id}">
                    <td><strong>${row.pc.pc_id}</strong><br><span class="tiny">${row.pc.name}</span><br><span class="tiny">${row.pc.role}</span></td>
                    <td>${row.assignedPapers.map((x) => `<span class="pill">${x.submission.submission_id}</span>`).join("") || `<span class="badge badge-warn">None</span>`}</td>
                    <td class="mono">${row.assignedPapers.length}/${state.assignment.workload}</td>
                  </tr>
                `;
              }).join("")}
            </tbody>
          </table>
        `;
      }

      [...container.querySelectorAll("tr.clickable")].forEach((tr) => {
        tr.addEventListener("click", () => {
          state.assignment.selected = { type: tr.dataset.type, id: tr.dataset.id };
          renderAssignmentList();
          renderAssignmentDetail();
        });
      });
    }

    function renderAssignmentDetail() {
      const panel = document.getElementById("assignmentDetailPanel");
      const result = state.assignment.result;
      const selected = state.assignment.selected;

      if (!result || !selected) {
        panel.innerHTML = `<div class="tiny">Select a paper or PC member to inspect topic distributions and alignment explanations.</div>`;
        return;
      }

      if (selected.type === "paper") {
        const row = result.byPaper.find((x) => x.submission.submission_id === selected.id);
        if (!row) return;
        panel.innerHTML = `
          <div class="tiny"><strong>Paper:</strong> ${row.submission.submission_id} - ${row.submission.title}</div>
          <div class="tiny"><strong>Authors:</strong> ${authorsLabel(row.submission.authors)}</div>
          <div class="tiny"><strong>Topic Tags:</strong> ${topicHintsLabel(row.submission.topic_hints)}</div>
          <div style="margin-top:8px"><strong style="font-size:0.82rem">Paper Topic Distribution</strong></div>
          ${barsHtml(row.submission.topicDist)}
          <div style="margin-top:10px"><strong style="font-size:0.82rem">Assigned PC Members</strong></div>
          ${row.assigned.map((a) => `
            <div class="detail-card" style="margin-top:8px;padding:8px">
              <div class="tiny"><strong>${a.pc.name}</strong> (${a.pc.pc_id}, ${a.pc.role})  similarity <span class="mono">${formatNum(a.score, 3)}</span></div>
              ${barsHtml(a.pc.topicDist, "warm")}
            </div>
          `).join("") || `<div class="tiny">No assigned members.</div>`}
        `;
      } else {
        const row = result.byPc.find((x) => x.pc.pc_id === selected.id);
        if (!row) return;
        panel.innerHTML = `
          <div class="tiny"><strong>PC Member:</strong> ${row.pc.name} (${row.pc.pc_id}, ${row.pc.role})</div>
          <div style="margin-top:8px"><strong style="font-size:0.82rem">PC Topic Distribution</strong></div>
          ${barsHtml(row.pc.topicDist)}
          <div style="margin-top:10px"><strong style="font-size:0.82rem">Assigned Submissions</strong></div>
          ${row.assignedPapers.map((x) => `
            <div class="detail-card" style="margin-top:8px;padding:8px">
              <div class="tiny"><strong>${x.submission.submission_id}</strong> - ${x.submission.title}</div>
              <div class="tiny">Authors: ${authorsLabel(x.submission.authors)}  similarity <span class="mono">${formatNum(x.score, 3)}</span></div>
              ${barsHtml(x.submission.topicDist, "warm")}
            </div>
          `).join("") || `<div class="tiny">No assigned submissions.</div>`}
        `;
      }
    }

    function renderAssignmentResults() {
      document.getElementById("assignmentSummary").innerHTML = assignmentSummaryCards();
      document.getElementById("assignTopKValue").textContent = String(state.assignment.topK);
      document.getElementById("assignmentUploadStatus").innerHTML = `
        submissions: <span class="mono">${state.assignment.submissions.length}</span> |
        pc members: <span class="mono">${state.assignment.pcMembers.length}</span> |
        COI pairs: <span class="mono">${state.assignment.coi.size}</span>
      `;
      renderAssignmentList();
      renderAssignmentDetail();
    }

    function supplyDistByRole(role, extraCandidates = []) {
      const basePcs = state.assignment.pcMembers.filter((pc) => pc.role === role);
      const all = [...basePcs, ...extraCandidates];
      if (!all.length) {
        const zero = {};
        leafIds.forEach((l) => { zero[l] = 0; });
        return normalizeDist(zero);
      }
      const dists = all.map((pc) => pc.topicDist || pcDist(pc));
      return avgDist(dists);
    }

    function demandDistFromSubmissions() {
      if (!state.assignment.submissions.length) {
        const zero = {};
        leafIds.forEach((l) => { zero[l] = 0; });
        return normalizeDist(zero);
      }
      return avgDist(state.assignment.submissions.map((s) => s.topicDist || submissionDist(s)));
    }

    function candidatePoolFiltered() {
      return state.discovery.externalCandidates
        .filter((c) => c.source === state.discovery.source)
        .filter((c) => c.role === state.discovery.role)
        .map((c) => ({ ...c, topicDist: c.topicDist || pcDist(c) }));
    }

    async function runDiscoverySearch(preserveSelection = false) {
      const count = Math.max(1, Number(document.getElementById("discoveryCountInput").value) || 1);
      const role = document.getElementById("discoveryRoleSelect").value;
      const source = document.getElementById("discoverySourceSelect").value;
      state.discovery.requiredCount = count;
      state.discovery.role = role;
      state.discovery.source = source;

      if (!state.assignment.submissions.length) {
        alert("Submission input is empty. Please upload submissions JSON before PC member discovery.");
        return;
      }
      if (!state.assignment.pcMembers.length) {
        alert("PC member input is empty. Please upload PC member JSON before PC member discovery.");
        return;
      }
      if (!state.discovery.externalCandidates.length) {
        alert("Candidate PC member source input is empty. Please upload or provide external candidates first.");
        return;
      }
      const hasScopedCandidates = state.discovery.externalCandidates.some((c) => c.source === source && c.role === role);
      if (!hasScopedCandidates) {
        alert(`No candidate PC members found for source "${source}" and role "${role}".`);
        return;
      }

      try {
        const resp = await apiPost("/discovery/run", {
          submissions: state.assignment.submissions,
          pc_members: state.assignment.pcMembers,
          external_candidates: state.discovery.externalCandidates,
          source,
          role,
          required_count: count,
          selected_ids: preserveSelection ? Array.from(state.discovery.selectedIds) : null
        });
        state.discovery.recommendedIds = resp.recommended_ids || [];
        state.discovery.selectedIds = new Set(resp.selected_ids || []);
        state.discovery.result = resp.result || null;
        renderDiscoveryResults();
      } catch (err) {
        alert(`Discovery backend error: ${err.message}`);
      }
    }

    function getDiscoverySelectedCandidates() {
      const pool = candidatePoolFiltered();
      const set = state.discovery.selectedIds;
      return pool.filter((c) => set.has(c.pc_id));
    }

    function getDiscoveryAugmentedSupply() {
      const role = state.discovery.role;
      const selected = getDiscoverySelectedCandidates();
      return supplyDistByRole(role, selected);
    }

    function gapBarsHtml(demand, supply, title) {
      const rows = leafIds.map((leaf) => ({
        leaf,
        demand: demand[leaf],
        supply: supply[leaf],
        gap: demand[leaf] - supply[leaf]
      })).sort((a, b) => Math.abs(b.gap) - Math.abs(a.gap));

      const maxGap = Math.max(0.0001, ...rows.map((r) => Math.abs(r.gap)));
      return `
        <div class="detail-card" style="margin-top:8px;padding:8px">
          <div class="tiny"><strong>${title}</strong></div>
          <div class="bars" style="margin-top:6px">
            ${rows.map((r) => `
              <div class="bar-row">
                <div>${byId[r.leaf].label}</div>
                <div class="bar-track"><div class="bar-fill ${r.gap >= 0 ? "warm" : "muted"}" style="width:${(Math.abs(r.gap) / maxGap * 100).toFixed(2)}%"></div></div>
                <div class="mono">${r.gap >= 0 ? "+" : ""}${formatNum(r.gap, 3)}</div>
              </div>
            `).join("")}
          </div>
        </div>
      `;
    }

    function renderDiscoveryResults() {
      const status = document.getElementById("discoveryInputStatus");
      status.innerHTML = `
        submissions in demand set: <span class="mono">${state.assignment.submissions.length}</span><br>
        current PC members: <span class="mono">${state.assignment.pcMembers.length}</span><br>
        source: <span class="mono">${state.discovery.source}</span>  role: <span class="mono">${state.discovery.role}</span>
      `;

      const result = state.discovery.result;
      const gapPanel = document.getElementById("discoveryGapPanel");
      const tablePanel = document.getElementById("discoveryCandidateTable");

      if (!result) {
        gapPanel.innerHTML = `<div class="tiny">Run search to compute current and augmented gap.</div>`;
        tablePanel.innerHTML = `<div class="tiny" style="padding:10px">No candidate list yet.</div>`;
        return;
      }

      const afterSupply = result.afterSupply || result.baseSupply;
      const beforeDist = Number(result.beforeDist || 0);
      const afterDist = Number(result.afterDist || 0);

      gapPanel.innerHTML = `
        <div class="summary">
          <div class="metric"><div class="label">Before TWD</div><div class="value">${formatNum(beforeDist, 3)}</div></div>
          <div class="metric"><div class="label">After TWD</div><div class="value">${formatNum(afterDist, 3)}</div></div>
          <div class="metric"><div class="label">Reduction</div><div class="value">${formatNum(beforeDist - afterDist, 3)}</div></div>
          <div class="metric"><div class="label">Selected Candidates</div><div class="value">${state.discovery.selectedIds.size}</div></div>
        </div>
        ${gapBarsHtml(result.demand || {}, result.baseSupply || {}, "Current Gap")}
        ${gapBarsHtml(result.demand || {}, afterSupply || {}, "Gap After Selected Candidates")}
      `;

      const pool = result.pool
        .map((c) => ({
          ...c,
          selected: state.discovery.selectedIds.has(c.pc_id),
          recommended: state.discovery.recommendedIds.includes(c.pc_id),
          gain: result.gains[c.pc_id] || 0
        }))
        .sort((a, b) => Number(b.recommended) - Number(a.recommended) || b.gain - a.gain);

      tablePanel.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Select</th>
              <th>Candidate</th>
              <th>Source</th>
              <th>Role</th>
              <th>Estimated Gain</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            ${pool.map((c) => `
              <tr>
                <td><input type="checkbox" data-cand-id="${c.pc_id}" ${c.selected ? "checked" : ""}></td>
                <td><strong>${c.name || c.pc_id}</strong><br><span class="tiny">${c.pc_id}</span></td>
                <td>${c.source}</td>
                <td>${c.role}</td>
                <td class="mono">${formatNum(c.gain, 3)}</td>
                <td>${c.recommended ? `<span class="badge badge-ok">Recommended</span>` : `<span class="badge badge-muted">Candidate</span>`}</td>
              </tr>
            `).join("") || `<tr><td colspan="6" class="tiny">No candidates from selected source + role.</td></tr>`}
          </tbody>
        </table>
      `;

      [...tablePanel.querySelectorAll('input[type="checkbox"][data-cand-id]')].forEach((cb) => {
        cb.addEventListener("change", () => {
          const id = cb.getAttribute("data-cand-id");
          if (cb.checked) state.discovery.selectedIds.add(id);
          else state.discovery.selectedIds.delete(id);
          void runDiscoverySearch(true);
        });
      });
    }

    function scheduleSessionId(slot, track) {
      return `slot_${slot}_track_${track}`;
    }

    function parseSessionId(sessionId) {
      const m = /slot_(\d+)_track_(\d+)/.exec(sessionId);
      if (!m) return { slot: 0, track: 0 };
      return { slot: Number(m[1]), track: Number(m[2]) };
    }

    async function runOralOrganization() {
      state.oral.parallelSessions = Math.max(1, Number(document.getElementById("oralParallelInput").value) || 1);
      state.oral.maxPerSession = Math.max(1, Number(document.getElementById("oralMaxInput").value) || 1);
      state.oral.timeSlots = Math.max(1, Number(document.getElementById("oralSlotsInput").value) || 1);

      if (!state.oral.papers.length) {
        alert("Oral paper list input is empty. Please upload the paper list first.");
        return;
      }

      try {
        const resp = await apiPost("/oral/run", {
          papers: state.oral.papers,
          parallel_sessions: state.oral.parallelSessions,
          max_per_session: state.oral.maxPerSession,
          time_slots: state.oral.timeSlots
        });
        state.oral.result = resp.result || null;
        renderOralResults();
      } catch (err) {
        alert(`Oral organization backend error: ${err.message}`);
      }
    }

    function setOralAssignment(paperId, sessionId) {
      const result = state.oral.result;
      if (!result) return;

      const paper = result.papers.find((p) => p.submission_id === paperId);
      if (!paper) return;

      result.sessions.forEach((s) => {
        s.papers = s.papers.filter((p) => p.submission_id !== paperId);
        s.centroid = s.papers.length ? avgDist(s.papers.map((x) => x.topicDist)) : null;
      });
      result.unassigned = result.unassigned.filter((p) => p.submission_id !== paperId);

      if (!sessionId) {
        result.unassigned.push(paper);
        result.assignment[paperId] = null;
        renderOralResults();
        return;
      }

      const target = result.sessions.find((s) => s.id === sessionId);
      if (!target) return;
      if (target.papers.length >= state.oral.maxPerSession) {
        alert("Selected session is full.");
        renderOralResults();
        return;
      }

      target.papers.push(paper);
      target.centroid = avgDist(target.papers.map((x) => x.topicDist));
      result.assignment[paperId] = sessionId;
      renderOralResults();
    }

    function renderOralResults() {
      const summary = document.getElementById("oralSummary");
      const schedulePanel = document.getElementById("oralSchedulePanel");
      const editorPanel = document.getElementById("oralEditorPanel");

      const result = state.oral.result;
      document.getElementById("oralUploadStatus").innerHTML = `oral papers loaded: <span class="mono">${state.oral.papers.length}</span>`;

      if (!result) {
        summary.innerHTML = `
          <div class="metric"><div class="label">Papers</div><div class="value">${state.oral.papers.length}</div></div>
          <div class="metric"><div class="label">Parallel Sessions</div><div class="value">${state.oral.parallelSessions}</div></div>
          <div class="metric"><div class="label">Time Slots</div><div class="value">${state.oral.timeSlots}</div></div>
          <div class="metric"><div class="label">Status</div><div class="value">Not Run</div></div>
        `;
        schedulePanel.innerHTML = `<div class="tiny" style="padding:10px">Run oral organization to generate schedule table.</div>`;
        editorPanel.innerHTML = `<div class="tiny" style="padding:10px">Manual editor appears after run.</div>`;
        return;
      }

      summary.innerHTML = `
        <div class="metric"><div class="label">Papers</div><div class="value">${result.papers.length}</div></div>
        <div class="metric"><div class="label">Sessions</div><div class="value">${result.sessions.length}</div></div>
        <div class="metric"><div class="label">Unassigned</div><div class="value">${result.unassigned.length}</div></div>
        <div class="metric"><div class="label">Capacity</div><div class="value">${state.oral.maxPerSession}</div></div>
      `;

      const T = state.oral.timeSlots;
      const K = state.oral.parallelSessions;

      schedulePanel.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Time Slot</th>
              ${Array.from({ length: K }, (_, i) => `<th>Track ${i + 1}</th>`).join("")}
            </tr>
          </thead>
          <tbody>
            ${Array.from({ length: T }, (_, tIdx) => {
              const slot = tIdx + 1;
              return `
                <tr>
                  <td><strong>Slot ${slot}</strong></td>
                  ${Array.from({ length: K }, (_, kIdx) => {
                    const track = kIdx + 1;
                    const sessionId = scheduleSessionId(slot, track);
                    const session = result.sessions.find((s) => s.id === sessionId);
                    const pills = session.papers.map((p) => `<span class="pill">${p.submission_id}: ${p.title}</span>`).join("") || `<span class="tiny">(empty)</span>`;
                    return `<td><div class="schedule-cell">${pills}</div></td>`;
                  }).join("")}
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      `;

      editorPanel.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Paper</th>
              <th>Current Assignment</th>
              <th>Move To Session</th>
            </tr>
          </thead>
          <tbody>
            ${result.papers.map((p) => {
              const cur = result.assignment[p.submission_id];
              const curTxt = cur ? (() => {
                const pos = parseSessionId(cur);
                return `Slot ${pos.slot} / Track ${pos.track}`;
              })() : "Unassigned";

              return `
                <tr>
                  <td><strong>${p.submission_id}</strong><br><span class="tiny">${p.title}</span></td>
                  <td>${curTxt}</td>
                  <td>
                    <select data-oral-paper="${p.submission_id}">
                      <option value="">Unassigned</option>
                      ${result.sessions.map((s) => `<option value="${s.id}" ${cur === s.id ? "selected" : ""}>Slot ${s.slot} / Track ${s.track}</option>`).join("")}
                    </select>
                  </td>
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      `;

      [...editorPanel.querySelectorAll("select[data-oral-paper]")].forEach((sel) => {
        sel.addEventListener("change", () => {
          const paperId = sel.getAttribute("data-oral-paper");
          const sessionId = sel.value || null;
          setOralAssignment(paperId, sessionId);
        });
      });
    }

    async function runPosterOrganization() {
      state.poster.rows = Math.max(1, Number(document.getElementById("posterRowsInput").value) || 1);
      state.poster.cols = Math.max(1, Number(document.getElementById("posterColsInput").value) || 1);
      state.poster.sessionCount = Math.max(1, Number(document.getElementById("posterSessionCountInput").value) || 1);

      if (!state.poster.papers.length) {
        alert("Poster paper list input is empty. Please upload the paper list first.");
        return;
      }

      try {
        const resp = await apiPost("/poster/run", {
          papers: state.poster.papers,
          rows: state.poster.rows,
          cols: state.poster.cols,
          session_count: state.poster.sessionCount
        });
        state.poster.result = resp.result || null;
        renderPosterResults();
      } catch (err) {
        alert(`Poster organization backend error: ${err.message}`);
      }
    }

    function firstEmptyCell(session) {
      return session.cells.findIndex((x) => x === null);
    }

    function setPosterPlacement(paperId, targetSessionId, targetCellIndex) {
      const result = state.poster.result;
      if (!result) return;
      const paper = result.papers.find((p) => p.submission_id === paperId);
      if (!paper) return;

      const oldPlacement = result.placements[paperId];
      if (oldPlacement) {
        const oldSession = result.sessions.find((s) => s.id === oldPlacement.sessionId);
        if (oldSession) oldSession.cells[oldPlacement.cellIndex] = null;
      }
      result.unassigned = result.unassigned.filter((p) => p.submission_id !== paperId);

      if (!targetSessionId || targetCellIndex === null || targetCellIndex === undefined || targetCellIndex === "") {
        result.placements[paperId] = null;
        result.unassigned.push(paper);
        renderPosterResults();
        return;
      }

      const targetSession = result.sessions.find((s) => s.id === targetSessionId);
      if (!targetSession) return;
      const cellIdx = Number(targetCellIndex);
      const occupant = targetSession.cells[cellIdx];

      if (occupant && occupant.submission_id !== paperId) {
        const freeIdx = firstEmptyCell(targetSession);
        if (freeIdx !== -1) {
          targetSession.cells[freeIdx] = occupant;
          result.placements[occupant.submission_id] = { sessionId: targetSession.id, cellIndex: freeIdx };
        } else {
          result.unassigned.push(occupant);
          result.placements[occupant.submission_id] = null;
        }
      }

      targetSession.cells[cellIdx] = paper;
      result.placements[paperId] = { sessionId: targetSession.id, cellIndex: cellIdx };
      renderPosterResults();
    }

    function renderPosterResults() {
      const summary = document.getElementById("posterSummary");
      const gridPanel = document.getElementById("posterGridPanel");
      const editorPanel = document.getElementById("posterEditorPanel");

      const result = state.poster.result;
      document.getElementById("posterUploadStatus").innerHTML = `poster papers loaded: <span class="mono">${state.poster.papers.length}</span>`;

      if (!result) {
        summary.innerHTML = `
          <div class="metric"><div class="label">Papers</div><div class="value">${state.poster.papers.length}</div></div>
          <div class="metric"><div class="label">Grid</div><div class="value">${state.poster.rows} x ${state.poster.cols}</div></div>
          <div class="metric"><div class="label">Sessions</div><div class="value">${state.poster.sessionCount}</div></div>
          <div class="metric"><div class="label">Status</div><div class="value">Not Run</div></div>
        `;
        gridPanel.innerHTML = `<div class="tiny">Run poster organization to generate arrangement table.</div>`;
        editorPanel.innerHTML = `<div class="tiny">Manual editor appears after run.</div>`;
        return;
      }

      summary.innerHTML = `
        <div class="metric"><div class="label">Papers</div><div class="value">${result.papers.length}</div></div>
        <div class="metric"><div class="label">Grid</div><div class="value">${state.poster.rows} x ${state.poster.cols}</div></div>
        <div class="metric"><div class="label">Sessions</div><div class="value">${result.sessions.length}</div></div>
        <div class="metric"><div class="label">Unassigned</div><div class="value">${result.unassigned.length}</div></div>
      `;

      gridPanel.innerHTML = result.sessions.map((session) => {
        return `
          <div class="poster-grid" style="margin-bottom:10px">
            <div style="padding:8px 10px;border-bottom:1px solid #e9f1ee;background:#f7fbfa"><strong>Session ${session.index}</strong></div>
            <table>
              <tbody>
                ${Array.from({ length: state.poster.rows }, (_, r) => {
                  return `
                    <tr>
                      ${Array.from({ length: state.poster.cols }, (_, c) => {
                        const idx = r * state.poster.cols + c;
                        const paper = session.cells[idx];
                        return `
                          <td class="poster-cell">
                            ${paper ? `<strong>${paper.submission_id}</strong><br><span class="tiny">${paper.title}</span>` : `<span class="tiny">(empty)</span>`}
                          </td>
                        `;
                      }).join("")}
                    </tr>
                  `;
                }).join("")}
              </tbody>
            </table>
          </div>
        `;
      }).join("") + (result.unassigned.length ? `<div class="tiny">Unassigned: ${result.unassigned.map((p) => p.submission_id).join(", ")}</div>` : "");

      const cellOptions = Array.from({ length: state.poster.rows * state.poster.cols }, (_, idx) => `<option value="${idx}">Cell ${idx + 1}</option>`).join("");

      editorPanel.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Paper</th>
              <th>Current Assignment</th>
              <th>Session</th>
              <th>Cell</th>
            </tr>
          </thead>
          <tbody>
            ${result.papers.map((p) => {
              const place = result.placements[p.submission_id];
              const curText = place
                ? `Session ${Number(place.sessionId.split("_").pop())}, Cell ${place.cellIndex + 1}`
                : "Unassigned";
              return `
                <tr>
                  <td><strong>${p.submission_id}</strong><br><span class="tiny">${p.title}</span></td>
                  <td>${curText}</td>
                  <td>
                    <select data-poster-paper="${p.submission_id}" data-field="session">
                      <option value="">Unassigned</option>
                      ${result.sessions.map((s) => `<option value="${s.id}" ${place && place.sessionId === s.id ? "selected" : ""}>Session ${s.index}</option>`).join("")}
                    </select>
                  </td>
                  <td>
                    <select data-poster-paper="${p.submission_id}" data-field="cell">
                      ${place ? cellOptions.replace(`value=\"${place.cellIndex}\"`, `value=\"${place.cellIndex}\" selected`) : `<option value="">n/a</option>${cellOptions}`}
                    </select>
                  </td>
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      `;

      [...editorPanel.querySelectorAll('select[data-poster-paper][data-field="session"]')].forEach((sel) => {
        sel.addEventListener("change", () => {
          const paperId = sel.getAttribute("data-poster-paper");
          const row = sel.closest("tr");
          const cellSel = row.querySelector('select[data-field="cell"]');
          const sessionId = sel.value || null;
          const cellIdx = sessionId ? Number(cellSel.value) : null;
          setPosterPlacement(paperId, sessionId, sessionId ? cellIdx : null);
        });
      });

      [...editorPanel.querySelectorAll('select[data-poster-paper][data-field="cell"]')].forEach((sel) => {
        sel.addEventListener("change", () => {
          const paperId = sel.getAttribute("data-poster-paper");
          const row = sel.closest("tr");
          const sessionSel = row.querySelector('select[data-field="session"]');
          const sessionId = sessionSel.value || null;
          if (!sessionId) {
            alert("Select a session first.");
            renderPosterResults();
            return;
          }
          setPosterPlacement(paperId, sessionId, Number(sel.value));
        });
      });
    }

    function downloadJson(filename, obj) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function refreshDiscoveryStatus() {
      document.getElementById("discoveryInputStatus").innerHTML = `
        submissions in demand set: <span class="mono">${state.assignment.submissions.length}</span><br>
        current PC members: <span class="mono">${state.assignment.pcMembers.length}</span><br>
        source: <span class="mono">${state.discovery.source}</span>  role: <span class="mono">${state.discovery.role}</span>
      `;
    }

    function switchTask(task) {
      state.activeTask = task;
      [...document.querySelectorAll(".nav-btn")].forEach((btn) => {
        btn.classList.toggle("is-active", btn.dataset.task === task);
      });
      [...document.querySelectorAll(".task-view")].forEach((view) => {
        view.classList.toggle("is-active", view.id === `task-${task}`);
      });
    }

    function setupEvents() {
      [...document.querySelectorAll(".nav-btn")].forEach((btn) => {
        btn.addEventListener("click", () => switchTask(btn.dataset.task));
      });

      document.getElementById("paperViewBtn").addEventListener("click", () => {
        state.assignment.viewMode = "paper";
        document.getElementById("paperViewBtn").classList.add("is-active");
        document.getElementById("pcViewBtn").classList.remove("is-active");
        renderAssignmentList();
        renderAssignmentDetail();
      });

      document.getElementById("pcViewBtn").addEventListener("click", () => {
        state.assignment.viewMode = "pc";
        document.getElementById("pcViewBtn").classList.add("is-active");
        document.getElementById("paperViewBtn").classList.remove("is-active");
        renderAssignmentList();
        renderAssignmentDetail();
      });

      document.getElementById("assignTopKInput").addEventListener("input", (e) => {
        document.getElementById("assignTopKValue").textContent = String(e.target.value);
      });

      document.getElementById("runAssignmentBtn").addEventListener("click", runAssignment);

      document.getElementById("uploadSubmissionBtn").addEventListener("click", () => {
        document.getElementById("submissionFileInput").click();
      });
      document.getElementById("submissionFileInput").addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        parseJsonFile(file, (payload) => {
          const rows = normalizeSubmissionList(payload);
          if (!rows.length) {
            alert("No valid submissions found in file.");
            return;
          }
          state.assignment.submissions = rows;
          state.assignment.result = null;
          renderAssignmentResults();
          refreshDiscoveryStatus();
        });
        e.target.value = "";
      });

      document.getElementById("uploadPcBtn").addEventListener("click", () => {
        document.getElementById("pcFileInput").click();
      });
      document.getElementById("pcFileInput").addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        parseJsonFile(file, (payload) => {
          const rows = normalizePcList(payload);
          if (!rows.length) {
            alert("No valid PC members found in file.");
            return;
          }
          state.assignment.pcMembers = rows;
          state.assignment.result = null;
          renderAssignmentResults();
          refreshDiscoveryStatus();
        });
        e.target.value = "";
      });

      document.getElementById("uploadCoiBtn").addEventListener("click", () => {
        document.getElementById("coiFileInput").click();
      });
      document.getElementById("coiFileInput").addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        parseJsonFile(file, (payload) => {
          state.assignment.coi = normalizeCoi(payload);
          state.assignment.result = null;
          renderAssignmentResults();
        });
        e.target.value = "";
      });

      document.getElementById("discoverySourceSelect").addEventListener("change", (e) => {
        state.discovery.source = e.target.value;
        refreshDiscoveryStatus();
      });
      document.getElementById("discoveryRoleSelect").addEventListener("change", (e) => {
        state.discovery.role = e.target.value;
        refreshDiscoveryStatus();
      });
      document.getElementById("runDiscoveryBtn").addEventListener("click", runDiscoverySearch);

      document.getElementById("uploadOralPapersBtn").addEventListener("click", () => {
        document.getElementById("oralFileInput").click();
      });
      document.getElementById("oralFileInput").addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        parseJsonFile(file, (payload) => {
          const rows = normalizeSubmissionList(payload);
          if (!rows.length) {
            alert("No valid oral papers found in file.");
            return;
          }
          state.oral.papers = rows;
          state.oral.result = null;
          renderOralResults();
        });
        e.target.value = "";
      });

      document.getElementById("runOralBtn").addEventListener("click", runOralOrganization);
      document.getElementById("exportOralBtn").addEventListener("click", () => {
        if (!state.oral.result) {
          alert("Run oral organization first.");
          return;
        }
        const output = {
          task: "oral_session_organization",
          parameters: {
            parallel_sessions: state.oral.parallelSessions,
            max_papers_per_session: state.oral.maxPerSession,
            time_slots: state.oral.timeSlots
          },
          assignments: state.oral.result.papers.map((p) => {
            const sid = state.oral.result.assignment[p.submission_id];
            if (!sid) return { paper_id: p.submission_id, session: null };
            const pos = parseSessionId(sid);
            return { paper_id: p.submission_id, session: { time_slot: pos.slot, track: pos.track } };
          })
        };
        downloadJson("oral_organization_result.json", output);
      });

      document.getElementById("uploadPosterPapersBtn").addEventListener("click", () => {
        document.getElementById("posterFileInput").click();
      });
      document.getElementById("posterFileInput").addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        parseJsonFile(file, (payload) => {
          const rows = normalizeSubmissionList(payload);
          if (!rows.length) {
            alert("No valid poster papers found in file.");
            return;
          }
          state.poster.papers = rows;
          state.poster.result = null;
          renderPosterResults();
        });
        e.target.value = "";
      });

      document.getElementById("runPosterBtn").addEventListener("click", runPosterOrganization);
      document.getElementById("exportPosterBtn").addEventListener("click", () => {
        if (!state.poster.result) {
          alert("Run poster organization first.");
          return;
        }
        const output = {
          task: "poster_session_organization",
          parameters: {
            rows: state.poster.rows,
            cols: state.poster.cols,
            session_count: state.poster.sessionCount
          },
          assignments: state.poster.result.papers.map((p) => {
            const place = state.poster.result.placements[p.submission_id];
            if (!place) return { paper_id: p.submission_id, assignment: null };
            const sessionNumber = Number(place.sessionId.split("_").pop());
            const row = Math.floor(place.cellIndex / state.poster.cols) + 1;
            const col = (place.cellIndex % state.poster.cols) + 1;
            return {
              paper_id: p.submission_id,
              assignment: {
                session: sessionNumber,
                row,
                col
              }
            };
          })
        };
        downloadJson("poster_organization_result.json", output);
      });
    }

    function init() {
      setupEvents();
      renderAssignmentResults();
      renderDiscoveryResults();
      renderOralResults();
      renderPosterResults();
      refreshDiscoveryStatus();
    }

    init();
  </script>
</body>
</html>
